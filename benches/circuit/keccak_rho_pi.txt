version 2.0.0;
subcircuit "keccak_rho_pi";
@type field 2;
@begin
  // 入力: 25レーン $0 .. $24
  // 出力: 25レーンの新状態（Rho と Pi を同時に適用）
  // Keccakの Rho では各レーンに対して個別の回転オフセット r[x,y] を適用し、
  // Pi で各レーンを別の位置に配置します。
  //
  // ここでは、各レーンについて以下の処理を行います:
  //    B[y, (2*x+3*y) mod 5] = ROT( A[x,y], r[x,y] )
  //
  // 例として、いくつかのレーンについてDSLで記述します。
  // 補助回路 "rot_const" は、入力ワイヤと定数回転量を受け取り回転結果を出力します。
  
  // --- レーン (0,0): x=0, y=0 ---
  // A(0,0) は $0, r[0,0] = 0 → 回転不要、Pi で新位置は (0,0)
  $25 <- @copy($0);
  
  // --- レーン (1,0): x=1, y=0 ---
  // A(1,0) は $1, r[1,0] = 36, 新位置: (0, (2*1+3*0 mod5)=2)
  $26 <- @call("rot_const", $1, <36>);
  
  // --- レーン (2,0): x=2, y=0 ---
  // A(2,0) は $2, r[2,0] = 3, 新位置: (0, (2*2+3*0 mod5)=4)
  $27 <- @call("rot_const", $2, <3>);
  
  // --- レーン (3,0): x=3, y=0 ---
  // A(3,0) は $3, r[3,0] = 41, 新位置: (0, (2*3+3*0 mod5)=1)
  $28 <- @call("rot_const", $3, <41>);
  
  // --- レーン (4,0): x=4, y=0 ---
  // A(4,0) は $4, r[4,0] = 18, 新位置: (0, (2*4+3*0 mod5)=3)
  $29 <- @call("rot_const", $4, <18>);
  
  // --- 以下、残りのレーンも同様に各回転量とPi変換に従って処理 ---
  // 例:
  // レーン (0,1): A(0,1) は $5, r[0,1] = 1, 新位置: (1, (2*0+3*1 mod5)=3)
  $30 <- @call("rot_const", $5, <1>);
  
  // レーン (1,1): A(1,1) は $6, r[1,1] = 44, 新位置: (1, (2*1+3*1 mod5)=0)
  $31 <- @call("rot_const", $6, <44>);
  
  // ...（中略：全25レーン分を実装）
  
  // 最後に、出力レーン $25 .. $49 を更新状態として入力状態 $0 .. $24 にコピー
  $0  <- @copy($25);
  $1  <- @copy($26);
  $2  <- @copy($27);
  $3  <- @copy($28);
  $4  <- @copy($29);
  $5  <- @copy($30);
  $6  <- @copy($31);
  // ...（残りも同様に）
@end
