version 2.0.0;
subcircuit "keccak_chi";
@type field 2;
@begin
  // 入力: 各行ごとに5レーンずつ、全体で $0 .. $24
  // Chi変換（各行 y に対して x=0..4）:
  // new A[x,y] = A[x,y] XOR ( (NOT A[x+1,y]) AND A[x+2,y] )
  //
  // ここでは、例として行 0（レーン $0～$4）の処理を示します。
  // 補助回路 "not" を用いてビット反転を実装し、mul を AND として利用します。
  
  // 行0, レーン0:
  $5  <- @call("not", $1);      // NOT A(1,0)
  $5  <- @mul(0: $5, $2);        // (NOT A(1,0)) AND A(2,0)
  $0  <- @add(0: $0, $5);        // A(0,0) XOR (...) → 新A(0,0)
  
  // 行0, レーン1:
  $6  <- @call("not", $2);      // NOT A(2,0)
  $6  <- @mul(0: $6, $3);        // (NOT A(2,0)) AND A(3,0)
  $1  <- @add(0: $1, $6);
  
  // 行0, レーン2:
  $7  <- @call("not", $3);      // NOT A(3,0)
  $7  <- @mul(0: $7, $4);        // (NOT A(3,0)) AND A(4,0)
  $2  <- @add(0: $2, $7);
  
  // 行0, レーン3:
  $8  <- @call("not", $4);      // NOT A(4,0)
  $8  <- @mul(0: $8, $0);        // (NOT A(4,0)) AND A(0,0)　※ラップアラウンド
  $3  <- @add(0: $3, $8);
  
  // 行0, レーン4:
  $9  <- @call("not", $0);      // NOT A(0,0)
  $9  <- @mul(0: $9, $1);        // (NOT A(0,0)) AND A(1,0)
  $4  <- @add(0: $4, $9);
  
  // 同様の処理を、行1（$5～$9）、行2（$10～$14）、行3（$15～$19）、行4（$20～$24）に対して実施
  // （ここでは省略。実際の回路では各行について同様に各レーンの更新制約を記述してください）
  
  // 出力: 更新後の状態は $0 .. $24 に反映
@end
