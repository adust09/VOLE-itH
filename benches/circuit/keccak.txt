version 2.0.0;
circuit;
@type field 2;
@begin
  // 1. 入力：1600ビットの初期状態（25×64ビット）をプライベート入力として受け取る
  $0 .. $24 <- @private_input(0);

  // 2. Keccak-f[1600] の 24 ラウンド実行
  // 各ラウンドは、以下の 5 ステップから構成される:
  //    (1) theta: 列ごとのパリティ計算と状態更新
  //    (2) rho & pi: 各語のビットローテーションと位置交換
  //    (3) chi: 非線形変換（各行ごとのビット演算）
  //    (4) iota: ラウンド定数の注入
  //    (5) （内部的に状態を更新）
  //
  // 各ラウンドでは、前段の状態（$0 .. $24）を入力として、
  // サブルーチン呼び出しにより次状態を得る。

  // --- ラウンド 0 ---
  $0 .. $24 <- @call("keccak_theta", $0 .. $24);
  $0 .. $24 <- @call("keccak_rho_pi", $0 .. $24);
  $0 .. $24 <- @call("keccak_chi", $0 .. $24);
  $0 .. $24 <- @call("keccak_iota", $0 .. $24, <RC0>);

  // --- ラウンド 1 ---
  $0 .. $24 <- @call("keccak_theta", $0 .. $24);
  $0 .. $24 <- @call("keccak_rho_pi", $0 .. $24);
  $0 .. $24 <- @call("keccak_chi", $0 .. $24);
  $0 .. $24 <- @call("keccak_iota", $0 .. $24, <RC1>);

  // --- ラウンド 2 から ラウンド 22 も同様に実行 ---
  // （ここでは省略しますが、各ラウンドごとに round constant <RC2> ... <RC22> を用いる）

  // --- ラウンド 23 ---
  $0 .. $24 <- @call("keccak_theta", $0 .. $24);
  $0 .. $24 <- @call("keccak_rho_pi", $0 .. $24);
  $0 .. $24 <- @call("keccak_chi", $0 .. $24);
  $0 .. $24 <- @call("keccak_iota", $0 .. $24, <RC23>);

  // 3. Squeeze（出力抽出）：SHA3-256の場合、状態の最初の 256 ビット（例として語 $0～$3）を出力とする
  $25 .. $28 <- @copy($0 .. $3);
  $25 .. $28 -> @public_input;
@end
